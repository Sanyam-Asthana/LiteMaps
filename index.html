<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LiteMaps</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Kalam:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        #canvas {
            background-color: #ffffff;
            cursor: default; 
            touch-action: none;
        }
        #text-input-container {
            position: absolute;
            display: none;
        }
        #text-input {
            font-family: 'Kalam', cursive;
            border: 1px dashed #666;
            background-color: #f0f0f0;
            padding: 5px;
            outline: none;
        }
        .tool-button {
            transition: all 0.2s ease-in-out;
        }
        .tool-button:hover {
            transform: scale(1.05);
        }
        .tool-button.active {
            background-color: #3b82f6;
            color: white;
            box-shadow: 0 0 0 2px #60a5fa;
        }

        .control-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background-color: #f3f4f6;
            padding: 0.25rem 0.5rem;
            border-radius: 0.5rem;
        }
        .control-wrapper input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 28px;
            height: 28px;
            background-color: transparent;
            border: none;
            cursor: pointer;
        }
        .control-wrapper input[type="color"]::-webkit-color-swatch {
            border-radius: 50%;
            border: 2px solid #e5e7eb;
        }
        .control-wrapper input[type="color"]::-moz-color-swatch {
            border-radius: 50%;
            border: 2px solid #e5e7eb;
        }
        .control-wrapper select {
            background-color: white;
            border-radius: 0.375rem;
            padding: 0.25rem;
            border: 1px solid #d1d5db;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            padding-right: 1.5rem;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.25em;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-5xl mx-auto">

        <header class="bg-white rounded-t-lg shadow-md p-4 flex flex-wrap justify-between items-center gap-4">
            <h1 class="text-2xl font-bold text-gray-800">LiteMaps</h1>
            <div id="toolbar" class="flex flex-wrap items-center gap-2">

                <div class="flex items-center space-x-2">
                    <button id="text-tool" class="tool-button bg-gray-200 text-gray-700 font-semibold py-2 px-4 rounded-lg shadow-sm active">Text</button>
                    <button id="arrow-tool" class="tool-button bg-gray-200 text-gray-700 font-semibold py-2 px-4 rounded-lg shadow-sm">Arrow</button>
                </div>

                <div class="flex items-center space-x-3">
                    <div class="control-wrapper">
                        <label for="text-color" class="text-sm font-medium text-gray-700">Text</label>
                        <input type="color" id="text-color" value="#1f2937">
                    </div>
                     <div class="control-wrapper">
                        <label for="text-size" class="text-sm font-medium text-gray-700">Size</label>
                        <select id="text-size">
                            <option value="16">16</option>
                            <option value="20" selected>20</option>
                            <option value="24">24</option>
                            <option value="32">32</option>
                            <option value="40">40</option>
                        </select>
                    </div>
                    <div class="control-wrapper">
                        <label for="arrow-color" class="text-sm font-medium text-gray-700">Arrow</label>
                        <input type="color" id="arrow-color" value="#1f2937">
                    </div>
                </div>

                <div class="flex items-center space-x-2">
                    <button id="export-png" class="tool-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-sm">Export as PNG</button>
                    <button id="clear-canvas" class="tool-button bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-sm">Clear</button>
                </div>
            </div>
        </header>


        <div class="bg-white rounded-b-lg shadow-lg overflow-hidden">
            <canvas id="canvas"></canvas>

            <div id="text-input-container">
                <input type="text" id="text-input" />
            </div>
        </div>
    </div>
    <center style="margin-top: 20px; color: gray;">By Sanyam Asthana</center>

    <script>
        window.addEventListener('DOMContentLoaded', () => {

            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const textInputContainer = document.getElementById('text-input-container');
            const textInput = document.getElementById('text-input');
            const textToolBtn = document.getElementById('text-tool');
            const arrowToolBtn = document.getElementById('arrow-tool');
            const exportBtn = document.getElementById('export-png');
            const clearBtn = document.getElementById('clear-canvas');
            const textColorPicker = document.getElementById('text-color');
            const arrowColorPicker = document.getElementById('arrow-color');
            const textSizePicker = document.getElementById('text-size');


            let nodes = []; 
            let arrows = []; 
            let isDrawing = false;
            let currentArrow = null;
            let activeTool = 'text';
            let textColor = textColorPicker.value;
            let arrowColor = arrowColorPicker.value;
            let textSize = textSizePicker.value;
            let editingNodeIndex = null; 
            let originalNode = null; 


            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientWidth * (9 / 16);
                redrawCanvas();
            }


            function redrawCanvas() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                nodes.forEach(node => {
                    ctx.font = `${node.size}px 'Kalam', cursive`;
                    ctx.fillStyle = node.color;
                    ctx.fillText(node.text, node.x, node.y);
                });

                arrows.forEach(arrow => {
                    drawArrow(arrow.startX, arrow.startY, arrow.endX, arrow.endY, arrow.color);
                });

                if (isDrawing && currentArrow) {
                    drawArrow(currentArrow.startX, currentArrow.startY, currentArrow.endX, currentArrow.endY, arrowColor);
                }
            }

            function drawArrow(fromx, fromy, tox, toy, color) {
                const headlen = 10;
                const dx = tox - fromx;
                const dy = toy - fromy;
                const angle = Math.atan2(dy, dx);

                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                
                const midX = fromx + dx / 2;
                const midY = fromy + dy / 2;
                const cpx = midX + dy * 0.2;
                const cpy = midY - dx * 0.2;
                ctx.moveTo(fromx, fromy);
                ctx.quadraticCurveTo(cpx, cpy, tox, toy);
                
                ctx.moveTo(tox, toy);
                ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
                ctx.moveTo(tox, toy);
                ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
                
                ctx.stroke();
            }


            function handleMouseDown(e) {
                if (activeTool !== 'arrow') return;
                isDrawing = true;
                const { x, y } = getCanvasCoordinates(e);
                currentArrow = { startX: x, startY: y, endX: x, endY: y };
            }

            function handleMouseMove(e) {
                if (activeTool === 'text') {
                    const { x, y } = getCanvasCoordinates(e);
                    const hoveredNode = nodes.find(node => isPointInNode(x, y, node));
                    canvas.style.cursor = hoveredNode ? 'pointer' : 'text';
                } else if (isDrawing && currentArrow) {
                    const { x, y } = getCanvasCoordinates(e);
                    currentArrow.endX = x;
                    currentArrow.endY = y;
                    redrawCanvas();
                }
            }

            function handleMouseUp(e) {
                if (!isDrawing || !currentArrow) return;
                isDrawing = false;
                const { x, y } = getCanvasCoordinates(e);
                currentArrow.endX = x;
                currentArrow.endY = y;
                if (Math.hypot(currentArrow.endX - currentArrow.startX, currentArrow.endY - currentArrow.startY) > 10) {
                    arrows.push({ ...currentArrow, color: arrowColor });
                }
                currentArrow = null;
                redrawCanvas();
            }

            function isPointInNode(x, y, node) {
                ctx.font = `${node.size}px 'Kalam', cursive`;
                const textWidth = ctx.measureText(node.text).width;
                return x >= node.x && x <= node.x + textWidth && y >= node.y - node.size && y <= node.y;
            }


            function handleCanvasClick(e) {
                if (activeTool !== 'text' || textInputContainer.style.display === 'block') return;

                const { x, y } = getCanvasCoordinates(e);
                const clickedNodeIndex = nodes.findIndex(node => isPointInNode(x, y, node));

                if (clickedNodeIndex !== -1) {
                    startEditing(clickedNodeIndex);
                }
            }


            function handleCanvasDoubleClick(e) {
                if (activeTool !== 'text') return;
                const { x, y } = getCanvasCoordinates(e);
                

                const clickedNode = nodes.some(node => isPointInNode(x, y, node));
                if (!clickedNode) {
                    showTextInput(x, y);
                }
            }

            function startEditing(index) {
                editingNodeIndex = index;
                originalNode = { ...nodes[index] }; 
                const nodeToEdit = nodes.splice(editingNodeIndex, 1)[0]; 


                textColorPicker.value = nodeToEdit.color;
                textSizePicker.value = nodeToEdit.size;
                textColor = nodeToEdit.color;
                textSize = nodeToEdit.size;

                redrawCanvas(); 
                showTextInput(nodeToEdit.x, nodeToEdit.y - nodeToEdit.size, nodeToEdit.text);
            }

            function showTextInput(x, y, initialText = '') {
                textInput.style.color = textColor;
                textInput.style.fontSize = `${textSize}px`;
                textInputContainer.style.left = `${canvas.offsetLeft + x}px`;
                textInputContainer.style.top = `${canvas.offsetTop + y}px`;
                textInputContainer.style.display = 'block';
                textInput.value = initialText;
                
                ctx.font = `${textSize}px 'Kalam', cursive`;
                const textWidth = ctx.measureText(textInput.value).width;
                textInput.style.width = `${Math.max(100, textWidth + 20)}px`;
                
                textInput.focus();
                textInput.select();
            }

            function handleTextInputBlur() {
                saveText();
                hideTextInput();
            }
            
            function handleTextInputKeyDown(e) {
                ctx.font = `${textSize}px 'Kalam', cursive`;
                const textWidth = ctx.measureText(textInput.value).width;
                textInput.style.width = `${Math.max(100, textWidth + 20)}px`;

                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveText();
                    hideTextInput();
                } else if (e.key === 'Escape') {
                    cancelEdit();
                }
            }

            function cancelEdit() {
                if (editingNodeIndex !== null) {
                    nodes.splice(editingNodeIndex, 0, originalNode); 
                }
                hideTextInput();
                redrawCanvas();
            }

            function saveText() {
                const text = textInput.value.trim();
                if (text) {
                    const x = parseInt(textInputContainer.style.left, 10) - canvas.offsetLeft;
                    const y = parseInt(textInputContainer.style.top, 10) - canvas.offsetTop + parseInt(textSize, 10);
                    ctx.font = `${textSize}px 'Kalam', cursive`;
                    const textMetrics = ctx.measureText(text);
                    const newNode = { text, x, y, width: textMetrics.width, color: textColor, size: textSize };

                    if (editingNodeIndex !== null) {
                        nodes.splice(editingNodeIndex, 0, newNode); 
                    } else {
                        nodes.push(newNode); 
                    }
                }
                redrawCanvas();
            }

            function hideTextInput() {
                editingNodeIndex = null;
                originalNode = null;
                textInputContainer.style.display = 'none';
                textInput.value = '';
            }

            function getCanvasCoordinates(event) {
                const rect = canvas.getBoundingClientRect();
                const clientX = event.clientX || event.touches[0].clientX;
                const clientY = event.clientY || event.touches[0].clientY;
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
            }

            function switchTool(tool) {
                activeTool = tool;
                textToolBtn.classList.toggle('active', tool === 'text');
                arrowToolBtn.classList.toggle('active', tool === 'arrow');
                canvas.style.cursor = tool === 'text' ? 'text' : 'crosshair';
                hideTextInput();
            }


            textToolBtn.addEventListener('click', () => switchTool('text'));
            arrowToolBtn.addEventListener('click', () => switchTool('arrow'));
            
            textColorPicker.addEventListener('input', (e) => { textColor = e.target.value; textInput.style.color = textColor; });
            arrowColorPicker.addEventListener('input', (e) => { arrowColor = e.target.value; });
            textSizePicker.addEventListener('input', (e) => { textSize = e.target.value; textInput.style.fontSize = `${textSize}px`; });

            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('dblclick', handleCanvasDoubleClick);
            
            textInput.addEventListener('keydown', handleTextInputKeyDown);
            textInput.addEventListener('blur', handleTextInputBlur);

            exportBtn.addEventListener('click', () => {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                tempCtx.fillStyle = '#FFFFFF';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                tempCtx.drawImage(canvas, 0, 0);
                const link = document.createElement('a');
                link.download = 'mind-map.png';
                link.href = tempCanvas.toDataURL('image/png');
                link.click();
            });
            
            clearBtn.addEventListener('click', () => {
                if(confirm('Are you sure you want to clear the entire canvas?')) {
                    nodes = [];
                    arrows = [];
                    redrawCanvas();
                }
            });

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            switchTool('text');
        });
    </script>
</body>
</html>
